{"meta":{"title":"Orange","subtitle":"个人博客","description":"","author":"Orange","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-07-14T07:43:10.000Z","updated":"2020-07-14T07:43:37.642Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"'小程序开发问题汇总'","slug":"小程序开发问题汇总","date":"2020-07-17T08:35:02.000Z","updated":"2020-07-17T08:37:43.216Z","comments":true,"path":"2020/07/17/小程序开发问题汇总/","link":"","permalink":"http://yoursite.com/2020/07/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"","text":"小程序开发问题汇总 多行文本省略问题 #text-overflow: ellipsis;只对display：inline；起作用 #多行显示用以下代码-webkit-line-clamp确定省略的行数 text-overflow: -o-ellipsis-lastline; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical;","categories":[],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"Docker介绍和演示","slug":"Docker介绍和演示","date":"2020-07-17T04:12:56.000Z","updated":"2020-07-18T07:14:35.016Z","comments":true,"path":"2020/07/17/Docker介绍和演示/","link":"","permalink":"http://yoursite.com/2020/07/17/Docker%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%BC%94%E7%A4%BA/","excerpt":"","text":"Docker介绍 docker相当于容器可以装好多个liunx ​ Docker安装mysql 使用阿里云镜像(安装完docker) 您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' &#123; \"registry-mirrors\": [\"https://jiwuvrmz.mirror.aliyuncs.com\"] &#125; EOF sudo systemctl daemon-reload sudo systemctl restart docker 默认安装最新版本的mysql (latest) docker pull mysql 安装指定版本的mysql docker pull mysql:8.0.20 安装mysql容器 docker run -p 3306:3306 --name mysql \\ -v /mydata/mysql/log:/var/log/mysql \\ -v /mydata/mysql/data:/var/lib/mysql \\ -v /mydata/mysql/conf:/etc/mysql \\ -e MYSQL_ROOT_PASSWORD=root \\ -d mysql:8.0.20 创建mysql配置文件 在/mydata/mysql/conf目录下创建文件my.cnf [client] default-character-set=utf8mb4 [mysql] default-character-set=utf8mb4 [mysqld] init_connect='SET collation_connection = utf8_unicode_ci' init_connect='SET NAMES utf8' character-set-server=utf8 collation-server=utf8_unicode_ci skip-character-set-client-handshake skip-name-resolve secure_file_priv=/var/lib/mysql skip-grant-tables #可以跳过登录mysql 重启容器 docker restart mysql 进入mysql容器(linux系统) docker exec -it mysql /bin/bash 查看是否成功修改 cat /etc/mysql/my.cnf 设置mysql随着docker自启 docker update mysql --restart=always docker update redis --restart=always mysql远程连接用户创建 必须先创建用户（密码规则：mysql8.0以上密码策略限制必须要大小写加数字特殊符号）： mysql&gt;create user orange@'%' identified by '密码'; 再进行赋值： mysql&gt;grant all privileges on *.* to orange@'%' with grant option; 最后刷新一下： mysql&gt;flush privileges; Docker 安装redis 安装redis镜像 docker pull redis 创建实例并启动 首先创建配置文件和目录 mkdir -p /mydata/redis/conf touch /mydata/redis/conf/redis.conf 启动容器 docker run -p 6379:6379 --name redis \\ -v /mydata/redis/data:/data \\ -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\ -d redis redis-server /etc/redis/redis.conf 运行redis docker exec -it redis redis-cli 开启 aof 持久化 vi /mydata/redis/conf/redis.conf # 添加如下内容 appendonly yes 重启redis docker restart redis 设置Docker自启动 docker update redis --restart=always","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]},{"title":"python gui界面和pygame库","slug":"python-gui界面和pygame库","date":"2020-07-16T15:04:49.000Z","updated":"2020-07-16T15:16:15.005Z","comments":true,"path":"2020/07/16/python-gui界面和pygame库/","link":"","permalink":"http://yoursite.com/2020/07/16/python-gui%E7%95%8C%E9%9D%A2%E5%92%8Cpygame%E5%BA%93/","excerpt":"","text":"gui界面设计和pygame tkinter 库 Label 和Button标签 # coding=gbk import tkinter as tk #界面配置 window = tk.Tk() #设置一个window界面 window.title('my window') #设置界面标题 window.geometry('300x300') #设置界面大小300x300像素 var = tk.StringVar() #tk字符串变量 l = tk.Label(window,textvariable=var,bg='green',font=('Arial',12),width=15,height=2) #Label的配置 l.pack() #放置Label标签 on_hit = False #设置点击事件 def hitMe(): global on_hit if on_hit == False: on_hit = True var.set(\"you hit me\") else: on_hit = False var.set('') bt = tk.Button(window,text='hit me',width=15,height=2,command=hitMe) #Button标签,command是事件方法 bt.pack() window.mainloop() #不断刷新界面 Entry 和Text 输入,文本框 # coding=gbk import tkinter as tk #界面配置 window = tk.Tk() #设置一个window界面 window.title('my window') #设置界面标题 window.geometry('300x300') #设置界面大小300x300像素 e = tk.Entry(window,show=None) #show可以设置字符样式 例如* e.pack() #设置点击事件 def insertPoint(): var = e.get() t.insert('insert',var) #设置insert方法 def insertEnd(): var = e.get() t.insert('end',var) #插入到最后面 def insertIndex(): var = e.get() t.insert(1.1,var) #插入到第一行第二列 bt1 = tk.Button(window,text='insert point',width=15,height=2,command=insertPoint) #Button标签,command是事件方法 bt1.pack() bt2 = tk.Button(window,text='insert end' ,width=15,height=2,command=insertEnd) bt2.pack() bt3 = tk.Button(window,text='insert index',width=15,height=2,command=insertIndex) bt3.pack() t = tk.Text(window,height=2) #Text标签 t.pack() window.mainloop() #不断刷新界面 Listbox 列表组件 # coding=gbk import tkinter as tk #界面配置 window = tk.Tk() #设置一个window界面 window.title('my window') #设置界面标题 window.geometry('300x300') #设置界面大小300x300像素 var1 = tk.StringVar() l = tk.Label(window,textvariable=var1,bg='green',width=4) l.pack() #设置点击事件 def insertPoint(): value = lstBox.get(lstBox.curselection()) #获取光标选定的值 var1.set(value) bt1 = tk.Button(window,text='print selection',width=15,height=2,command=insertPoint) #Button标签,command是事件方法 bt1.pack() var2 = tk.StringVar() var2.set((11,22,33,44,55)) lstBox = tk.Listbox(window,listvariable=var2) #listBox标签,用listvariable定义list lstBox.pack() #插入listBox第二种方法 list_items = [1,2,3,4,5] for item in list_items: lstBox.insert('end',item) #插入listBox第三种方法 lstBox.insert(1,'first') lstBox.insert(2,'second') # lstBox.delete(1) window.mainloop() #不断刷新界面 Radiobutton 选择按钮 # coding=gbk import tkinter as tk #界面配置 window = tk.Tk() #设置一个window界面 window.title('my window') #设置界面标题 window.geometry('300x300') #设置界面大小300x300像素 var = tk.StringVar() l = tk.Label(window,text='empty',bg='green',width=20) l.pack() def printSelection(): l.config(text='you have selected ' + var.get()) r1 = tk.Radiobutton(window,text='Option A',variable=var,value='A',command=printSelection) #Radiobutton标签,将value赋值给variable,command是点击按钮方法 r1.pack() r2 = tk.Radiobutton(window,text='Option B',variable=var,value='B',command=printSelection) #Radiobutton标签,将value赋值给variable r2.pack() window.mainloop() #不断刷新界面 Scale 尺度 # coding=gbk import tkinter as tk #界面配置 window = tk.Tk() #设置一个window界面 window.title('my window') #设置界面标题 window.geometry('300x300') #设置界面大小300x300像素 var = tk.StringVar() l = tk.Label(window,text='empty',bg='green',width=20) l.pack() def printSelection(v): ''' :param v: value的值 :return: ''' l.config(text='you have selected ' + v) s = tk.Scale(window,label='try me',from_=5,to=11,orient=tk.HORIZONTAL,length=300,showvalue=1,tickinterval=3,resolution=0.01,command=printSelection) #Scale标签,从5到10,横项的,长度300,是否显示0,步长3,精度0.01 s.pack() window.mainloop() #不断刷新界面 Checkbutton 勾选项 # coding=gbk import tkinter as tk #界面配置 window = tk.Tk() #设置一个window界面 window.title('my window') #设置界面标题 window.geometry('300x300') #设置界面大小300x300像素 var = tk.StringVar() l = tk.Label(window,text='empty',bg='green',width=20) l.pack() def printSelection(): print(var1.get(),var2.get()) if var1.get() == 1 and var2.get() == 0: l.config(text='I love only Python') elif var1.get() == 0 and var2.get() == 1: l.config(text='I love only C++') elif var1.get() == 0 and var2.get() == 0: l.config(text='I do not love either') else: l.config(text='I love both') var1 = tk.IntVar() var2 = tk.IntVar() c1 = tk.Checkbutton(window,text='Python',variable=var1,onvalue=1,offvalue=0,command=printSelection) #Checkbutton标签,选中赋值var1为1,不选中为0 c2 = tk.Checkbutton(window,text='C++',variable=var2,onvalue=1,offvalue=0,command=printSelection) #Checkbutton标签,选中赋值var1为1,不选中为0 c1.pack() c2.pack() window.mainloop() #不断刷新界面 Canvas 画布 # coding=gbk import tkinter as tk #界面配置 window = tk.Tk() #设置一个window界面 window.title('my window') #设置界面标题 window.geometry('300x300') #设置界面大小300x300像素 canvas = tk.Canvas(window,bg='blue',height=150,width=300,) image_file = tk.PhotoImage(file='tk.gif') #获取图片,只能是gif image = canvas.create_image(10,10,anchor='nw',image=image_file) #创建图片,锚定的点为nw方向 x0,y0,x1,y1 = 50,50,80,80 line = canvas.create_line(x0,y0,x1,y1) #画线从(x0,y0)画到(x1,y1) oval = canvas.create_oval(x0,y0,x1,y1,fill='red') #画圆 arc = canvas.create_arc(x0+30,y0+30,x1+30,y1+30,start=0,extent=180) #扇形 rect = canvas.create_rectangle(200,20,200+30,20+30) #矩形 canvas.pack() def moveIt(): canvas.move(rect,0,2) #移动平移0,下移2 b = tk.Button(window,text='move',command=moveIt).pack() window.mainloop() #不断刷新界面 Menubar 菜单 # coding=gbk import tkinter as tk #界面配置 window = tk.Tk() #设置一个window界面 window.title('my window') #设置界面标题 window.geometry('300x300') #设置界面大小300x300像素 l = tk.Label(window,text='',bg='green',width=20) l.pack() count = 0 def doJob(): global count l.config(text='do' + str(count)) count += 1 menubar = tk.Menu(window) #Menu标签 file_menu = tk.Menu(menubar,tearoff=0) #tearoff能否被分开 menubar.add_cascade(label='File',menu=file_menu) #将file_menu放在Menu上 file_menu.add_command(label='New',command=doJob) #增加菜单的功能 file_menu.add_command(label='Open',command=doJob) file_menu.add_command(label='Save',command=doJob) file_menu.add_separator() #加一条分离线 file_menu.add_command(label='Exit',command=window.quit) edit_menu = tk.Menu(menubar,tearoff=0) #tearoff能否被分开 menubar.add_cascade(label='Edit',menu=edit_menu) #将file_menu放在Menu上 edit_menu.add_command(label='Cut',command=doJob) #增加菜单的功能 edit_menu.add_command(label='Copy',command=doJob) edit_menu.add_command(label='Paste',command=doJob) sub_menu = tk.Menu(menubar,tearoff=0) #file_menu中的分支 file_menu.add_cascade(label='Import',menu=sub_menu,underline=0) sub_menu.add_command(label='Submenu1',command=doJob) window.config(menu=menubar) window.mainloop() #不断刷新界面 Frame 框架布局 # coding=gbk import tkinter as tk #界面配置 window = tk.Tk() #设置一个window界面 window.title('my window') #设置界面标题 window.geometry('300x300') #设置界面大小300x300像素 tk.Label(window,text='on the window').pack() frm = tk.Frame(window) #创建一个frame frm.pack() frm_left = tk.Frame(frm) #将frm_left放在frm中 frm_right = tk.Frame(frm) frm_left.pack(side='left') #放在左边 frm_right.pack(side='right') tk.Label(frm_left,text='on the frm_l1').pack() tk.Label(frm_left,text='on the frm_l2').pack() tk.Label(frm_right,text='on the frm_r1').pack() window.mainloop() #不断刷新界面 Messagebox 弹窗 # coding=gbk import tkinter as tk from tkinter import messagebox #界面配置 window = tk.Tk() #设置一个window界面 window.title('my window') #设置界面标题 window.geometry('300x300') #设置界面大小300x300像素 def hitMe(): # tk.messagebox.showinfo(title='hi',message='哈哈哈') #弹窗 # tk.messagebox.showwarning(title='hi',message='no') #警告 # tk.messagebox.showerror(title='hi',message='哈哈哈') #程序不能运行 # tk.messagebox.askquestion(title='hi',message='哈哈哈') #return yes or no # r = tk.messagebox.askyesno(title='hi',message='哈哈哈') #return True or False # tk.messagebox.askretrycancel(title='hi',message='哈哈哈') #return True or False tk.messagebox.askyesnocancel(title='hi',message='哈哈哈') #return True or False tk.Button(window,text='hit me',command=hitMe).pack() window.mainloop() #不断刷新界面 pack grid place 放置位置 # coding=gbk import tkinter as tk from tkinter import messagebox #界面配置 window = tk.Tk() #设置一个window界面 window.title('my window') #设置界面标题 window.geometry('300x300') #设置界面大小300x300像素 #pack用法 # tk.Label(window,bg='green',text=1).pack(side='top') # tk.Label(window,bg='green',text=1).pack(side='bottom') # tk.Label(window,bg='green',text=1).pack(side='left') # tk.Label(window,bg='green',text=1).pack(side='right') #grid用法 # for i in range(4): # for j in range(3): # tk.Label(window,bg='green',text=1).grid(row=i,column=j,padx=10,pady=10)#间隔 #place用法 tk.Label(window,bg='green',text=1).place(x=10,y=100,anchor='nw') window.mainloop() #不断刷新界面 登录实例 pygame 库 相关对象 #屏幕尺寸和模式 pygame.display.set_mode(size) #设置窗口大小 #一个参数设置大小 #另一个参数设置屏幕模式 pygame.RESIZABLE #可调节 pygame.FULLSCREEN #全屏 pygame.NOFRAME #无边框 pygame.display.Info() #生成屏幕相关信息,return 分辨率xXy #对象有 current_w #横 current_h #纵 #窗口图标和标题 pygame.display.set_icon() #设置图标信息 pygame.display.set_caption() #设置窗口标题 pygame.display.get_caption() #获得标题和小标题(title,icontitle) #窗口感知和刷新 pygame.display.get_active() #当窗口在系统中显示时返回True or False pygame.display.filp() #重新绘制整个屏幕对应的窗口 pygame.display.update() #刷新屏幕 #事件 event.type pygame.KEYDOWN #键盘事件 返回event.key,event.unicode编码,event.mod修饰符 pygame.k_UP pygame.k_DOWN pygame.k_LEFT pygame.k_RIGHT pygame.QUIT #退出事件 pygame.VIDEORESIZE #窗口大小更改事件 返回event.size pygame.size[0] #宽度 pygame.size[1] #高度 pygame.image.load('ball.gif') #加载图片 get_rect() #使得图片对象有一个矩形边 fclock = pygame.time.Clock() #用于操作时间 fclock.tick(fps) #控制帧的刷新速度每秒进行fps次帧 screen.fill(BLACK) #填充黑色 screen.blit(ball,ballrect) #将ball图像绘制到ballrect上 pygame.KEYDOWN #键盘敲击事件 #处理事件 pygame.event.get() pygame.event.poll() pygame.event.clear() #操作事件队列 pygame.event.set_blocked(type or typelist) #控制事件不允许保存到事件队列中 pygame.event.get_blocked(type) #判断事件是否被禁止,返回True or False pygame.event.set_allowed(type or typelist) #控制事件允许保存到事件队列中 #生成事件 pygame.event.post(Event) #产生一个事件放入事件队列,一般用于用户自定义事件(pygame.USEREVENT) pygame.event.Event(type,dict) #创建给定类型的事件 #鼠标事件 pygame.event.MOUSEMOTION #鼠标移动事件 event.pos #鼠标当前坐标(x,y),相对于窗口左上角 event.rel #鼠标相对运动距离(x,y),相当于上次事件 event.buttons #鼠标移动的三个键状态对应位置值为1反之为0 pygame.event.MOUSEBUTTONUP #鼠标释放事件 event.pos #鼠标当前坐标(x,y),相对于窗口左上角 event.button #鼠标的键分别对应0/1/2 pygame.event.MOUSEBUTTONDOWN #鼠标键按下事件 event.pos #鼠标当前坐标(x,y),相对于窗口左上角 event.button #鼠标的键左键为1,右键为3 #颜色 pygame.Color(rgba or color) #a可选 默认255 不透明为0 .r #红色通道 0-255 .g #绿色通道 0-255 .b #蓝色通道 0-255 #图形绘制机制 pygame.Rect() #返回(left,top) width height .copy() .move() #移动,传入速度 .inflate() .clamp() .clip() .union() .unionall() .fit() .normalize() #详情可参考http://www.pygame.org/docs/ref/rect.html pygame.draw .rect() #矩形 #参数 Surface #矩形绘制的屏幕 Color #矩形绘制的颜色 Rect #矩形绘制的区域 width #绘制边缘的宽度,默认为0,即填充图形 .line() #直线 Surface #矩形绘制的屏幕 Color #矩形绘制的颜色 (start_pos,end_pos) #直线起始坐标 width #直线的宽度,默认为1 .polygon() #多边形 Surface #矩形绘制的屏幕 Color #矩形绘制的颜色 pointlist #多变形顶点坐标列表 width #绘制边缘的宽度,默认为0,即填充图形 .circle() #圆形 Surface #矩形绘制的屏幕 Color #矩形绘制的颜色 pos #圆心坐标 radius #半径 width .ellipse() #椭圆形 Surface #矩形绘制的屏幕 Color #矩形绘制的颜色 Rect #矩形绘制的区域 width .arc() #椭圆弧形 .lines() #连续多线 Surface #矩形绘制的屏幕 Color #矩形绘制的颜色 closed #如果为True,起止节点自动增加封闭直线 postlist #直线起始坐标列表 width #直线的宽度,默认为1 .aaline() #无锯齿线 .aalines() #连续无锯齿线 Surface #矩形绘制的屏幕 Color #矩形绘制的颜色 closed #如果为True,起止节点自动增加封闭直线 postlist #直线起始坐标列表 blend = 1 #不为0时,线条所在的背景颜色进行混合 #文字绘制机制 pygame.freetype #需要额外impot pygame.freetype.Font(字体路径,大小) #生成字体对象 .render_to() #返回Rect对象 #参数 surf #绘制字体的屏幕 dest #具体位置(x,y) text #绘制的文字内容 fgcolor #文字颜色 bgcolor #背景颜色 rotation #逆时针旋转角度 size #字体大小 .render() #绘制具体文字 返回Rect和Surface对象 #参数 text #文字内容 fgcolor,bgcolor rotation size pygame最小开发框架 # coding=gbk import pygame,sys pygame.init() #初始化游戏设置 screen = pygame.display.set_mode((600,400)) #设置屏幕大小 pygame.display.set_caption('游戏开发之旅') #设置标题 #实现事件无线循环,直到游戏退出 while True: for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() pygame.display.update() 小球碰壁 # coding=gbk import pygame,sys #游戏初始化 pygame.init() #初始化游戏设置 size = width,height = 600,400 speed = [1,1] print(speed[0]) BLACK = 0,0,0 still = False bgcolor = pygame.Color('black') screen = pygame.display.set_mode(size,pygame.RESIZABLE) #设置屏幕大小 pygame.display.set_caption('小球碰壁') #设置标题 ball = pygame.image.load('ball.gif') icon = pygame.image.load('ball.gif') pygame.display.set_icon(icon) ballrect = ball.get_rect() fps =300 fclock = pygame.time.Clock() #用于操作时间 def RGBChannel(a): return 0 if a&lt;0 else (255 if a&gt;255 else int(a)) #实现事件无线循环,直到游戏退出 while True: #事件 for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() elif event.type == pygame.KEYDOWN: if event.key == pygame.K_LEFT: speed[0] = speed[0] if speed[0] == 0 else (abs(speed[0]) - 1) * int(speed[0]/abs(speed[0])) elif event.key == pygame.K_RIGHT: speed[0] = speed[0] + 1 if speed[0] &gt; 0 else speed[0] - 1 elif event.key == pygame.K_UP: speed[1] = speed[1] + 1 if speed[1] &gt; 0 else speed[1] - 1 elif event.key == pygame.K_DOWN: speed[1] = speed[1] if speed[1] == 0 else (abs(speed[1]) - 1) * int(speed[1]/abs(speed[1])) elif event.key == pygame.K_ESCAPE: sys.exit() elif event.type == pygame.VIDEORESIZE: size = width,height = event.size[0],event.size[1] screen = pygame.display.set_mode(size,pygame.RESIZABLE) elif event.type == pygame.MOUSEBUTTONDOWN: if event.button == 1: still = True elif event.type == pygame.MOUSEBUTTONUP: still = False if event.button == 1: ballrect = ballrect.move(event.pos[0] - ballrect.left,event.pos[1] - ballrect.top) elif event.type == pygame.MOUSEMOTION: ballrect = ballrect.move(event.pos[0] - ballrect.left,event.pos[1] - ballrect.top) if pygame.display.get_active() and not still: ballrect = ballrect.move(speed[0],speed[1]) #移动 if ballrect.left &lt; 0 or ballrect.right &gt; width: speed[0] = -speed[0] if ballrect.right &gt; width and ballrect.right + speed[0] &gt; ballrect.right: speed[0] = -speed[0] if ballrect.top &lt; 0 or ballrect.bottom &gt; height: speed[1] = -speed[1] if ballrect.bottom &gt; height and ballrect.bottom + speed[1] &gt; ballrect.bottom: speed[1] = -speed[1] bgcolor.r = RGBChannel(ballrect.left*255/width) bgcolor.g = RGBChannel(ballrect.top*255/height) bgcolor.b = RGBChannel(min(speed[0],speed[1])*255/max(speed[0],speed[1],1)) screen.fill(bgcolor) #填充黑色 screen.blit(ball,ballrect) #将ball图像绘制到ballrect上 pygame.display.update() fclock.tick(fps) #控制帧的刷新速度每秒进行fps次帧","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"Python库","slug":"Python/Python库","permalink":"http://yoursite.com/categories/Python/Python%E5%BA%93/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Gui界面","slug":"Gui界面","permalink":"http://yoursite.com/tags/Gui%E7%95%8C%E9%9D%A2/"},{"name":"Pygame","slug":"Pygame","permalink":"http://yoursite.com/tags/Pygame/"}]},{"title":"Django rest framework","slug":"Django-rest-framework","date":"2020-07-16T15:00:31.000Z","updated":"2020-07-16T15:02:04.867Z","comments":true,"path":"2020/07/16/Django-rest-framework/","link":"","permalink":"http://yoursite.com/2020/07/16/Django-rest-framework/","excerpt":"","text":"Django rest framework 基础构建 首先startapp api 接着将rest_framework,api注册到app中 之后 #setting.py REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAdminUser', ], #配置全局权限 'DEFAULT_AUTHENTICATION_CLASSES':[], #配置全局认证 'PAGE_SIZE': 10 &#125; #局部的view.py可以设置空的认证 authentication_classes = [] 认证 CBV 模式 请求进来先执行dispatch,接着执行请求方式 token 实现基本认证 首先要创建两张表 #view.py from django.shortcuts import render,HttpResponse from rest_framework.views import APIView from rest_framework.authentication import BasicAuthentication from rest_framework import exceptions import json def get_token_code(username): \"\"\" 根据用户名和时间戳来生成永不相同的token随机字符串 :param username: 字符串格式的用户名 :return: 字符串格式的Token \"\"\" import time import hashlib timestamp = str(time.time()) m = hashlib.md5(username.encode(\"utf-8\")) # md5 要传入字节类型的数据 m.update(timestamp.encode(\"utf-8\")) return m.hexdigest() # 将生成的随机字符串返回 class GoodsView(APIView): authentication_classes = [MyAuthentication,] def get(self,request): ret = &#123; 'code':1000, 'msg':'xxx' &#125; return HttpResponse(json.dumps(ret)) class AuthView(APIView): ''' 用户登录 ''' authentication_classes = [] def post(self,request,*args,**kwargs): data = request.POST print(data) username = data['username'] password = data['password'] user = models.User.objects.filter(username=username,password=password).first() if not user: return HttpResponse(json.dumps(&#123;'code':1002,'message':'登录失败'&#125;)) else: res = &#123;'code':1000&#125; token = get_token_code(username) models.UserToken.objects.update_or_create(user=user,defaults=&#123;\"token\":token&#125;) res['token'] = token return HttpResponse(json.dumps(res)) #auth.py from rest_framework import exceptions from rest_framework.authentication import BaseAuthentication from users import models class MyAuthentication(BaseAuthentication): ''' 用户认证 ''' def authenticate(self, request): meth = request.method token = request.data.get('token') # _request是原生的request token_obj = models.UserToken.objects.filter(token=token).first() if not token: raise exceptions.AuthenticationFailed('用户认证失败') return (token_obj.user,token) def authenticate_header(self, val): pass 权限 #permisssion.py from rest_framework import permissions from rest_framework.permissions import BasePermission class MyPermission(BasePermission): def has_permission(self, request, view): if request.user.gender == '女': return False #无权限 return True #有权限 频率 #throttle.py from rest_framework.throttling import BaseThrottle import time VISIT_RECORD = &#123;&#125; class AuthThrottle(BaseThrottle): def allow_request(self, request, view): #获取ip地址 remote_addr = self.get_ident(request) ctime = time.time() if remote_addr not in VISIT_RECORD: VISIT_RECORD[remote_addr] = [ctime,] #将ip地址存入 return True #return False 表示访问频率太高被限制 history = VISIT_RECORD.get(remote_addr) history.insert(0,ctime) while history and history[-1] &lt; ctime - 60: history.pop() if len(history) &lt; 3: return True def wait(self): '''还需要等待多长时间''' ctime = time.time() return 60 - (ctime - self.history[-1]) 内置访问频率 #setting.py REST_FRAMEWORK = &#123; 'DEFAULT_THROTTLE_CLASSES':[],#配置全局频率 'DEFAULT_THROTTLE_RATES':&#123; 'wyc':'3/m' #每分钟三次 ,'wyc' 需要设置 scope &#125;, &#125; #throttle.py from rest_framework.throttling import SimpleRateThrottle class MyThrottle(SimpleRateThrottle): scope = 'wyc' #全局配置中的key def get_cache_key(self, request, view): return self.get_ident(request) 版本 1.通过get传参 #setting.py REST_FRAMEWORK = &#123; 'DEFAULT_VERSION':'v1', 'ALLOWED_VERSION':['v1','v2'], 'VERSION_PARAM':'version' &#125; #自定义 from rest_framework.versioning import BaseVersioning class ParamVersion(BaseVersioning): def determine_version(self, request, *args, **kwargs): version = request.query_params.get('version') #传入version参数 return version versioning_class = ParamVersion #内置 from rest_framework.versioning import QueryParameterVersioning versioning_class = QueryParameterVersioning 2.通过路由 #urls.py REST_FRAMEWORK = &#123; 'DEFAULT_VERSIONING_CLASS':\"rest_framework.versioning.URLPathVersioning\", 'DEFAULT_VERSION':'v1', 'ALLOWED_VERSION':['v1','v2'], 'VERSION_PARAM':'version' &#125; 解析器 #全局配置 REST_FRAMEWORK = &#123; 'DEFAULT_PARSER_CLASSES': ['rest_framework.parsers.JSONParser','rest_framework.parsers.FormParser'], &#125; from rest_framework.parsers import JSONParser,FormParser class (): parser_classes = [JSONParser,FormParser] ''' JSONParser: 允许用户发json格式数据 a.content-type:application/json b.request.data获取数据 FormParser: a.content-type:application/x-www-form-unlencoded头 b.可以用request.data获取数据 ''' 在APIView中封装的request，就实现了请求数据的解析： 对于GET请求的参数我们通过request.query_params来获取。 对于POST请求、PUT请求的数据我们通过request.data来获取。 序列化 #urls.py对单个数据查询 url(r'goods/(?P&lt;pk&gt;\\d+)$',views.GoodsView.as_view()), class GoodsView(APIView): def get(self,request,*args,**kwargs): print(request.user,request.auth) pk = kwargs.get('pk') goods = models.Goods.objects.filter(id=pk).first() ser = serializer.GoodsSerializer(goods,many=False) return Response(ser.data) #serializer.py from rest_framework import serializers from users import models class GoodsSerializer(serializers.ModelSerializer): class Meta: models = models.Goods fields = \"__all__\" depth = 0 #深度用来查看外键表的数据 #view.py class GoodsView(APIView): def get(self,request): print(request.user,request.auth) goods = models.Goods.objects.all() ser = serializer.GoodsSerializer(goods,many=True) return Response(ser.data) #校验 class GoodsSerializer(serializers.Serializer): title = serializers.CharField(error_messages=&#123;'required':'标题不能为空'&#125;) class GoodsView(APIView): def post(self,request,*args,**kwargs): ser = serializer.GoodsSerializer(data=request.data) if ser.is_valid(): print(ser.validated_data) else: print(ser.errors) 视图 #url.py url(r'^good/$',views.GenView.as_view(&#123;'get':'list','post':'create'&#125;)), url(r'^good/(?P&lt;pk&gt;\\d+)/$',views.GenView.as_view(&#123;'get':'retrieve','put':'update','delete':'destroy','patch':'partial_update','post':'create'&#125;)), #view.py from rest_framework.viewsets import ModelViewSet from rest_framework.pagination import PageNumberPagination class GenView(ModelViewSet): authentication_classes = [] queryset = models.Goods.objects.all() serializer_class = serializer.GoodsSerializer pagination_class = PageNumberPagination 路由 #url.py from rest_framework import routers router = routers.DefaultRouter() router.register(r'good',views.GenView) urlpatterns = [ url(r'',include(router.urls)) #自动添加view相关的路由,四个 ]","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"http://yoursite.com/categories/Python/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"Django基础配置和知识","slug":"Django基础配置和知识","date":"2020-07-15T09:14:30.000Z","updated":"2020-07-15T09:17:05.951Z","comments":true,"path":"2020/07/15/Django基础配置和知识/","link":"","permalink":"http://yoursite.com/2020/07/15/Django%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E5%92%8C%E7%9F%A5%E8%AF%86/","excerpt":"","text":"Django基础配置 新建的目录 1.static 用来存放静态文件例如:js,css 2.log 用来存放日志文件 3.media 用来存放上传的文件 4.apps 用来存放各个app ,将apps右键设置Mark Directory as Resoruce Root方便引入app view.py setting.py 配置 #中文配置 # _*_ coding:utf-8 _*_ #static文件配置 STATICFILES_DIRS=[ os.path.join(BASE_DIR,\"static\") ] #apps文件配置 sys.path.insert(0,os.path.join(BASE_DIR,'apps')) #数据库配置需要在文件__init__.py下 import pymysql pymysql.install_as_MySQLdb() DATABASES = &#123; \"default\": &#123; \"ENGINE\": \"django.db.backends.mysql\", \"NAME\": \"missgoods\", # 需要自己手动创建数据库 \"USER\": \"用户名\", \"PASSWORD\": \"密码\", \"HOST\": \"localhost\", \"POST\": 3306, 'OPTIONS': &#123;'charset':'utf8mb4'&#125; &#125; &#125; #时区配置 TIME_ZONE = 'Asia/Shanghai' USE_TZ = False #restframework配置 REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAdminUser', ], 'PAGE_SIZE': 10 &#125; #media配置 MEDIA_ROOT = os.path.join(BASE_DIR,\"media\") MEDIA_URL = \"/media/\" #需在url.py中配置 from django.conf.urls.static import static from django.conf import settings urlpatterns + static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT) users的设计 #1.创建一个users app #2.设计model.py from django.contrib.auth.models import AbstractUser class User(AbstractUser): nick_name = models.CharField(max_length=50,verbose_name=\"昵称\",default=\"管理员\") birthday = models.DateField(verbose_name='生日',null=True,blank=True) gender = models.CharField(choices=((\"男\"),(\"女\")),default=\"女\") class Meta: verbose_name = \"用户\" verbose_name_plural = verbose_name #3.配置setting.py AUTH_USER_MODEL = \"users.User\" #4.配置amdmin.py注册表 from django.contrib import admin from .models import User class UserAdmin(admin.ModelAdmin): pass admin.site.register(User,UserAdmin) #ps:如果需要迁移数据库需要删除 django.contrib.admin 和 django.contrib.auth 中的migrations manage.py 命令 python manage.py + 1.startapp [app名称] #setting.py中配置 INSTALLED_APPS = [ 'app名称' ] 2.runserver 运行项目 3.makemigrations [app名称]生成默认数据表 4.migrate [app名称]生成数据库 url.py配置 from django.conf.urls import url,include from django.conf.urls.static import static from django.conf import settings urlpatterns = [ url('admin/', admin.site.urls), url('/',include('app名称.urls')), ] + static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT) xadmin #创建一个extra_apps #放入xadmin源码 #url配置 import xadmin urlpatterns = [ url('xadmin/', xadmin.site.urls), ] #setting.py配置 INSTALLED_APPS = [ 'xadmin', 'crispy_forms' ] #进行makemigrations migrate #注册model #首先在app中创建一个adminx.py文件 import xadmin from .models import model名称 class model名称Admin(Object): list_display = ['model属性'] #用来显示 search_fields = ['model属性'] #用来搜索 list_filter = ['model属性] #用来筛选 model_icon = '' #设置左边的图标 ordering = ['upTime'] #排序 xadmin.site.register(model名称,modelmingcAdmin) #注册 #全局配置 #随便进入一个adminx.py文件配置 from xadmin import views class BaseSetting(object): enable_themes = True #主题功能 use_bootswatch = True xadmin.site.register(views.BaseAdminView,BaseSetting) class GlobalSetting(object): site_title = \"智能物品招领\" #最左上角的标题 site_footer = \"招领\" #底部的标题 xadmin.site.register(views.CommAdminView,GlobalSetting) #页面app的修改方式 #1.在apps.py中 class UsersConfig(AppConfig): name = 'users' verbose_name = \"用户操作\" #修改名称 #2.在app的__init__.py中 default_app_config =\"users.apps.UsersConfig\" Django 基础知识 orm与model #model.py from django.db import models class 表名(models.Model): auto_now_add=True #创建数据生成的时间 AutoField(Field) - int自增列，必须填入参数 primary_key=True BigAutoField(AutoField) - bigint自增列，必须填入参数 primary_key=True 注：当model中如果没有自增列，则自动会创建一个列名为id的列 from django.db import models class UserInfo(models.Model): # 自动创建一个列名为id的且为自增的整数列 username = models.CharField(max_length=32) class Group(models.Model): # 自定义自增列 nid = models.AutoField(primary_key=True) name = models.CharField(max_length=32) SmallIntegerField(IntegerField): - 小整数 -32768 ～ 32767 PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField) - 正小整数 0 ～ 32767 IntegerField(Field) - 整数列(有符号的) -2147483648 ～ 2147483647 PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField) - 正整数 0 ～ 2147483647 BigIntegerField(IntegerField): - 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807 BooleanField(Field) - 布尔值类型 NullBooleanField(Field): - 可以为空的布尔值 CharField(Field) - 字符类型 - 必须提供max_length参数， max_length表示字符长度 TextField(Field) - 文本类型 EmailField(CharField)： - 字符串类型，Django Admin以及ModelForm中提供验证机制 IPAddressField(Field) - 字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制 GenericIPAddressField(Field) - 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6 - 参数： protocol，用于指定Ipv4或Ipv6， 'both',\"ipv4\",\"ipv6\" unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启此功能，需要protocol=\"both\" URLField(CharField) - 字符串类型，Django Admin以及ModelForm中提供验证 URL SlugField(CharField) - 字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号） CommaSeparatedIntegerField(CharField) - 字符串类型，格式必须为逗号分割的数字 UUIDField(Field) - 字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证 FilePathField(Field) - 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能 - 参数： path, 文件夹路径 match=None, 正则匹配 recursive=False, 递归下面的文件夹 allow_files=True, 允许文件 allow_folders=False, 允许文件夹 FileField(Field) - 字符串，路径保存在数据库，文件上传到指定目录 - 参数： upload_to = \"\" 上传文件的保存路径 storage = None 存储组件，默认django.core.files.storage.FileSystemStorage ImageField(FileField) - 字符串，路径保存在数据库，文件上传到指定目录 - 参数： upload_to = \"\" 上传文件的保存路径 storage = None 存储组件，默认django.core.files.storage.FileSystemStorage width_field=None, 上传图片的高度保存的数据库字段名（字符串） height_field=None 上传图片的宽度保存的数据库字段名（字符串） DateTimeField(DateField) - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] DateField(DateTimeCheckMixin, Field) - 日期格式 YYYY-MM-DD TimeField(DateTimeCheckMixin, Field) - 时间格式 HH:MM[:ss[.uuuuuu]] DurationField(Field) - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型 FloatField(Field) - 浮点型 DecimalField(Field) - 10进制小数 - 参数： max_digits，小数总长度 decimal_places，小数位长度 BinaryField(Field) - 二进制类型 class Meta: verbose_name = u\"表名\" verbose_name_plural = verbose_name def __unicode__(self): return self.属性名","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"http://yoursite.com/categories/Python/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"hexo +github+阿里云全站加速搭建个人博客","slug":"hexo +github+阿里云全站加速搭建个人博客","date":"2020-07-14T16:00:00.000Z","updated":"2020-07-15T08:48:40.842Z","comments":true,"path":"2020/07/15/hexo +github+阿里云全站加速搭建个人博客/","link":"","permalink":"http://yoursite.com/2020/07/15/hexo%20+github+%E9%98%BF%E9%87%8C%E4%BA%91%E5%85%A8%E7%AB%99%E5%8A%A0%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"1. 前言 1.1 准备工作 一个github账号 安装了 node.js 和 git，使用npm 安装好git 之后，右键打开git bash here输入git信息，下面信息可以填你自己的 git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" 2. 搭建博客 2.1 创建GitHub仓库 ​ 在github里新建一个你的用户名.github.io的仓库，必须是你的GitHub用户名,不然无效，这样将来可以访问你的地址 https://你的用户名.github.io 2.2 全局安装hexo ​ 你可以打开git bash here输入npm install -g hexo-cli 进行安装 2.3 初始化一个hexo项目 ​ 可以在桌面上新建一个文件夹叫做myblog用于以后在里面写博客再上传到github里，然后打开这个文件夹的cmd如下所示（以下命令都是在这个cmd中操作） ​ 接着输入hexo init进行初始化项目,会生成如下目录 ​ 此时本地的仓库初始化完成了，你可以输入hexo server打开本地服务进行查看 2.4 部署到github 打开_congig.yml文件找到deploy进行如下配置： deploy: type: git repo: https://github.com/你的github用户名/你的github用户名.github.io.git branch: master 接着需要一个hexo插件来帮助我们推到github的仓库里面，安装插件： npm install hexo-deployer-git --save 最后只要输入： hexo clean hexo deploy 第一个命令用于清除缓存，第二个用于上传github仓库期间可能需要你登录一个github账号密码，之后写md博客的时候都需要使用这两个命令，这时候就已经部署成功了，打开https://你的用户名.github.io就可以访问了 2.5 更换主题皮肤 在hexo官网找到自己喜欢的theme主题，然后git clone到目录的theme里面 然后将主题名称配置在_congig.yml文件中： # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: 安装的主题名称 然后再利用hexo clean和hexo deploy上传到github里，之后本地进行的修改都要及时上传 ​ 3. 阿里云全站加速 ​ 为什么要使用阿里云全站加速呢，因为这样可以使得我们的博客访问的速度变得更快，当然觉得繁琐可以跳过这一部分 3.1 准备工作 购买一个域名，用来映射github域名（需要备案）可以先用域名加速 用阿里云购买一个全站加速，按量收费即可，基本不花钱 3.2 使用全站加速 首先需要添加域名 ​ 域名填写你的域名 源站信息选择IP,填写如下信息 ​ 上述信息是github的ip地址端口是443，需要填写四个，git pages会在这四个地址中变化 解析域名 ​ 打开解析添加一条记录，记录类型选择CNAME，主机记录按照你加速的域名填，根据下表： ​ 记录值是刚刚全站加速添加域名的CNAME ​ 之后添加即可。 与github域名绑定 在本地的myblog文件中的source目录创建一个CNAME文件，在里面用编辑器输入你在全站加速里面添加的域名。用hexo deploy上传到github就可以了。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"Docker在linux系统安装","slug":"Docker在linux系统安装","date":"2020-07-14T14:09:53.000Z","updated":"2020-07-15T03:17:50.161Z","comments":true,"path":"2020/07/14/Docker在linux系统安装/","link":"","permalink":"http://yoursite.com/2020/07/14/Docker%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","excerpt":"","text":"Docker在linux系统安装 删除旧版本的docker目录文件 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装docker的仓库(repository) $ sudo yum install -y yum-utils $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 下载docker驱动 $ sudo yum install docker-ce docker-ce-cli containerd.io 启动docker $ sudo systemctl start docker 设置docker开机自启 $ sudo systemctl enable docker 查看镜像列表 $ sudo docker images 查看容器列表 $ sudo docker ps","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]}],"categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"Python库","slug":"Python/Python库","permalink":"http://yoursite.com/categories/Python/Python%E5%BA%93/"},{"name":"Django","slug":"Python/Django","permalink":"http://yoursite.com/categories/Python/Django/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Gui界面","slug":"Gui界面","permalink":"http://yoursite.com/tags/Gui%E7%95%8C%E9%9D%A2/"},{"name":"Pygame","slug":"Pygame","permalink":"http://yoursite.com/tags/Pygame/"},{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]}