{"meta":{"title":"Orange","subtitle":"个人博客","description":"","author":"Orange","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-07-14T07:43:10.000Z","updated":"2020-07-14T07:43:37.642Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Django rest framework","slug":"Django-rest-framework","date":"2020-07-16T15:00:31.000Z","updated":"2020-07-16T15:02:04.867Z","comments":true,"path":"2020/07/16/Django-rest-framework/","link":"","permalink":"http://yoursite.com/2020/07/16/Django-rest-framework/","excerpt":"","text":"Django rest framework 基础构建 首先startapp api 接着将rest_framework,api注册到app中 之后 #setting.py REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAdminUser', ], #配置全局权限 'DEFAULT_AUTHENTICATION_CLASSES':[], #配置全局认证 'PAGE_SIZE': 10 &#125; #局部的view.py可以设置空的认证 authentication_classes = [] 认证 CBV 模式 请求进来先执行dispatch,接着执行请求方式 token 实现基本认证 首先要创建两张表 #view.py from django.shortcuts import render,HttpResponse from rest_framework.views import APIView from rest_framework.authentication import BasicAuthentication from rest_framework import exceptions import json def get_token_code(username): \"\"\" 根据用户名和时间戳来生成永不相同的token随机字符串 :param username: 字符串格式的用户名 :return: 字符串格式的Token \"\"\" import time import hashlib timestamp = str(time.time()) m = hashlib.md5(username.encode(\"utf-8\")) # md5 要传入字节类型的数据 m.update(timestamp.encode(\"utf-8\")) return m.hexdigest() # 将生成的随机字符串返回 class GoodsView(APIView): authentication_classes = [MyAuthentication,] def get(self,request): ret = &#123; 'code':1000, 'msg':'xxx' &#125; return HttpResponse(json.dumps(ret)) class AuthView(APIView): ''' 用户登录 ''' authentication_classes = [] def post(self,request,*args,**kwargs): data = request.POST print(data) username = data['username'] password = data['password'] user = models.User.objects.filter(username=username,password=password).first() if not user: return HttpResponse(json.dumps(&#123;'code':1002,'message':'登录失败'&#125;)) else: res = &#123;'code':1000&#125; token = get_token_code(username) models.UserToken.objects.update_or_create(user=user,defaults=&#123;\"token\":token&#125;) res['token'] = token return HttpResponse(json.dumps(res)) #auth.py from rest_framework import exceptions from rest_framework.authentication import BaseAuthentication from users import models class MyAuthentication(BaseAuthentication): ''' 用户认证 ''' def authenticate(self, request): meth = request.method token = request.data.get('token') # _request是原生的request token_obj = models.UserToken.objects.filter(token=token).first() if not token: raise exceptions.AuthenticationFailed('用户认证失败') return (token_obj.user,token) def authenticate_header(self, val): pass 权限 #permisssion.py from rest_framework import permissions from rest_framework.permissions import BasePermission class MyPermission(BasePermission): def has_permission(self, request, view): if request.user.gender == '女': return False #无权限 return True #有权限 频率 #throttle.py from rest_framework.throttling import BaseThrottle import time VISIT_RECORD = &#123;&#125; class AuthThrottle(BaseThrottle): def allow_request(self, request, view): #获取ip地址 remote_addr = self.get_ident(request) ctime = time.time() if remote_addr not in VISIT_RECORD: VISIT_RECORD[remote_addr] = [ctime,] #将ip地址存入 return True #return False 表示访问频率太高被限制 history = VISIT_RECORD.get(remote_addr) history.insert(0,ctime) while history and history[-1] &lt; ctime - 60: history.pop() if len(history) &lt; 3: return True def wait(self): '''还需要等待多长时间''' ctime = time.time() return 60 - (ctime - self.history[-1]) 内置访问频率 #setting.py REST_FRAMEWORK = &#123; 'DEFAULT_THROTTLE_CLASSES':[],#配置全局频率 'DEFAULT_THROTTLE_RATES':&#123; 'wyc':'3/m' #每分钟三次 ,'wyc' 需要设置 scope &#125;, &#125; #throttle.py from rest_framework.throttling import SimpleRateThrottle class MyThrottle(SimpleRateThrottle): scope = 'wyc' #全局配置中的key def get_cache_key(self, request, view): return self.get_ident(request) 版本 1.通过get传参 #setting.py REST_FRAMEWORK = &#123; 'DEFAULT_VERSION':'v1', 'ALLOWED_VERSION':['v1','v2'], 'VERSION_PARAM':'version' &#125; #自定义 from rest_framework.versioning import BaseVersioning class ParamVersion(BaseVersioning): def determine_version(self, request, *args, **kwargs): version = request.query_params.get('version') #传入version参数 return version versioning_class = ParamVersion #内置 from rest_framework.versioning import QueryParameterVersioning versioning_class = QueryParameterVersioning 2.通过路由 #urls.py REST_FRAMEWORK = &#123; 'DEFAULT_VERSIONING_CLASS':\"rest_framework.versioning.URLPathVersioning\", 'DEFAULT_VERSION':'v1', 'ALLOWED_VERSION':['v1','v2'], 'VERSION_PARAM':'version' &#125; 解析器 #全局配置 REST_FRAMEWORK = &#123; 'DEFAULT_PARSER_CLASSES': ['rest_framework.parsers.JSONParser','rest_framework.parsers.FormParser'], &#125; from rest_framework.parsers import JSONParser,FormParser class (): parser_classes = [JSONParser,FormParser] ''' JSONParser: 允许用户发json格式数据 a.content-type:application/json b.request.data获取数据 FormParser: a.content-type:application/x-www-form-unlencoded头 b.可以用request.data获取数据 ''' 在APIView中封装的request，就实现了请求数据的解析： 对于GET请求的参数我们通过request.query_params来获取。 对于POST请求、PUT请求的数据我们通过request.data来获取。 序列化 #urls.py对单个数据查询 url(r'goods/(?P&lt;pk&gt;\\d+)$',views.GoodsView.as_view()), class GoodsView(APIView): def get(self,request,*args,**kwargs): print(request.user,request.auth) pk = kwargs.get('pk') goods = models.Goods.objects.filter(id=pk).first() ser = serializer.GoodsSerializer(goods,many=False) return Response(ser.data) #serializer.py from rest_framework import serializers from users import models class GoodsSerializer(serializers.ModelSerializer): class Meta: models = models.Goods fields = \"__all__\" depth = 0 #深度用来查看外键表的数据 #view.py class GoodsView(APIView): def get(self,request): print(request.user,request.auth) goods = models.Goods.objects.all() ser = serializer.GoodsSerializer(goods,many=True) return Response(ser.data) #校验 class GoodsSerializer(serializers.Serializer): title = serializers.CharField(error_messages=&#123;'required':'标题不能为空'&#125;) class GoodsView(APIView): def post(self,request,*args,**kwargs): ser = serializer.GoodsSerializer(data=request.data) if ser.is_valid(): print(ser.validated_data) else: print(ser.errors) 视图 #url.py url(r'^good/$',views.GenView.as_view(&#123;'get':'list','post':'create'&#125;)), url(r'^good/(?P&lt;pk&gt;\\d+)/$',views.GenView.as_view(&#123;'get':'retrieve','put':'update','delete':'destroy','patch':'partial_update','post':'create'&#125;)), #view.py from rest_framework.viewsets import ModelViewSet from rest_framework.pagination import PageNumberPagination class GenView(ModelViewSet): authentication_classes = [] queryset = models.Goods.objects.all() serializer_class = serializer.GoodsSerializer pagination_class = PageNumberPagination 路由 #url.py from rest_framework import routers router = routers.DefaultRouter() router.register(r'good',views.GenView) urlpatterns = [ url(r'',include(router.urls)) #自动添加view相关的路由,四个 ]","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"http://yoursite.com/categories/Python/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"Django基础配置和知识","slug":"Django基础配置和知识","date":"2020-07-15T09:14:30.000Z","updated":"2020-07-15T09:17:05.951Z","comments":true,"path":"2020/07/15/Django基础配置和知识/","link":"","permalink":"http://yoursite.com/2020/07/15/Django%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E5%92%8C%E7%9F%A5%E8%AF%86/","excerpt":"","text":"Django基础配置 新建的目录 1.static 用来存放静态文件例如:js,css 2.log 用来存放日志文件 3.media 用来存放上传的文件 4.apps 用来存放各个app ,将apps右键设置Mark Directory as Resoruce Root方便引入app view.py setting.py 配置 #中文配置 # _*_ coding:utf-8 _*_ #static文件配置 STATICFILES_DIRS=[ os.path.join(BASE_DIR,\"static\") ] #apps文件配置 sys.path.insert(0,os.path.join(BASE_DIR,'apps')) #数据库配置需要在文件__init__.py下 import pymysql pymysql.install_as_MySQLdb() DATABASES = &#123; \"default\": &#123; \"ENGINE\": \"django.db.backends.mysql\", \"NAME\": \"missgoods\", # 需要自己手动创建数据库 \"USER\": \"用户名\", \"PASSWORD\": \"密码\", \"HOST\": \"localhost\", \"POST\": 3306, 'OPTIONS': &#123;'charset':'utf8mb4'&#125; &#125; &#125; #时区配置 TIME_ZONE = 'Asia/Shanghai' USE_TZ = False #restframework配置 REST_FRAMEWORK = &#123; 'DEFAULT_PERMISSION_CLASSES': [ 'rest_framework.permissions.IsAdminUser', ], 'PAGE_SIZE': 10 &#125; #media配置 MEDIA_ROOT = os.path.join(BASE_DIR,\"media\") MEDIA_URL = \"/media/\" #需在url.py中配置 from django.conf.urls.static import static from django.conf import settings urlpatterns + static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT) users的设计 #1.创建一个users app #2.设计model.py from django.contrib.auth.models import AbstractUser class User(AbstractUser): nick_name = models.CharField(max_length=50,verbose_name=\"昵称\",default=\"管理员\") birthday = models.DateField(verbose_name='生日',null=True,blank=True) gender = models.CharField(choices=((\"男\"),(\"女\")),default=\"女\") class Meta: verbose_name = \"用户\" verbose_name_plural = verbose_name #3.配置setting.py AUTH_USER_MODEL = \"users.User\" #4.配置amdmin.py注册表 from django.contrib import admin from .models import User class UserAdmin(admin.ModelAdmin): pass admin.site.register(User,UserAdmin) #ps:如果需要迁移数据库需要删除 django.contrib.admin 和 django.contrib.auth 中的migrations manage.py 命令 python manage.py + 1.startapp [app名称] #setting.py中配置 INSTALLED_APPS = [ 'app名称' ] 2.runserver 运行项目 3.makemigrations [app名称]生成默认数据表 4.migrate [app名称]生成数据库 url.py配置 from django.conf.urls import url,include from django.conf.urls.static import static from django.conf import settings urlpatterns = [ url('admin/', admin.site.urls), url('/',include('app名称.urls')), ] + static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT) xadmin #创建一个extra_apps #放入xadmin源码 #url配置 import xadmin urlpatterns = [ url('xadmin/', xadmin.site.urls), ] #setting.py配置 INSTALLED_APPS = [ 'xadmin', 'crispy_forms' ] #进行makemigrations migrate #注册model #首先在app中创建一个adminx.py文件 import xadmin from .models import model名称 class model名称Admin(Object): list_display = ['model属性'] #用来显示 search_fields = ['model属性'] #用来搜索 list_filter = ['model属性] #用来筛选 model_icon = '' #设置左边的图标 ordering = ['upTime'] #排序 xadmin.site.register(model名称,modelmingcAdmin) #注册 #全局配置 #随便进入一个adminx.py文件配置 from xadmin import views class BaseSetting(object): enable_themes = True #主题功能 use_bootswatch = True xadmin.site.register(views.BaseAdminView,BaseSetting) class GlobalSetting(object): site_title = \"智能物品招领\" #最左上角的标题 site_footer = \"招领\" #底部的标题 xadmin.site.register(views.CommAdminView,GlobalSetting) #页面app的修改方式 #1.在apps.py中 class UsersConfig(AppConfig): name = 'users' verbose_name = \"用户操作\" #修改名称 #2.在app的__init__.py中 default_app_config =\"users.apps.UsersConfig\" Django 基础知识 orm与model #model.py from django.db import models class 表名(models.Model): auto_now_add=True #创建数据生成的时间 AutoField(Field) - int自增列，必须填入参数 primary_key=True BigAutoField(AutoField) - bigint自增列，必须填入参数 primary_key=True 注：当model中如果没有自增列，则自动会创建一个列名为id的列 from django.db import models class UserInfo(models.Model): # 自动创建一个列名为id的且为自增的整数列 username = models.CharField(max_length=32) class Group(models.Model): # 自定义自增列 nid = models.AutoField(primary_key=True) name = models.CharField(max_length=32) SmallIntegerField(IntegerField): - 小整数 -32768 ～ 32767 PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField) - 正小整数 0 ～ 32767 IntegerField(Field) - 整数列(有符号的) -2147483648 ～ 2147483647 PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField) - 正整数 0 ～ 2147483647 BigIntegerField(IntegerField): - 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807 BooleanField(Field) - 布尔值类型 NullBooleanField(Field): - 可以为空的布尔值 CharField(Field) - 字符类型 - 必须提供max_length参数， max_length表示字符长度 TextField(Field) - 文本类型 EmailField(CharField)： - 字符串类型，Django Admin以及ModelForm中提供验证机制 IPAddressField(Field) - 字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制 GenericIPAddressField(Field) - 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6 - 参数： protocol，用于指定Ipv4或Ipv6， 'both',\"ipv4\",\"ipv6\" unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启此功能，需要protocol=\"both\" URLField(CharField) - 字符串类型，Django Admin以及ModelForm中提供验证 URL SlugField(CharField) - 字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号） CommaSeparatedIntegerField(CharField) - 字符串类型，格式必须为逗号分割的数字 UUIDField(Field) - 字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证 FilePathField(Field) - 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能 - 参数： path, 文件夹路径 match=None, 正则匹配 recursive=False, 递归下面的文件夹 allow_files=True, 允许文件 allow_folders=False, 允许文件夹 FileField(Field) - 字符串，路径保存在数据库，文件上传到指定目录 - 参数： upload_to = \"\" 上传文件的保存路径 storage = None 存储组件，默认django.core.files.storage.FileSystemStorage ImageField(FileField) - 字符串，路径保存在数据库，文件上传到指定目录 - 参数： upload_to = \"\" 上传文件的保存路径 storage = None 存储组件，默认django.core.files.storage.FileSystemStorage width_field=None, 上传图片的高度保存的数据库字段名（字符串） height_field=None 上传图片的宽度保存的数据库字段名（字符串） DateTimeField(DateField) - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ] DateField(DateTimeCheckMixin, Field) - 日期格式 YYYY-MM-DD TimeField(DateTimeCheckMixin, Field) - 时间格式 HH:MM[:ss[.uuuuuu]] DurationField(Field) - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型 FloatField(Field) - 浮点型 DecimalField(Field) - 10进制小数 - 参数： max_digits，小数总长度 decimal_places，小数位长度 BinaryField(Field) - 二进制类型 class Meta: verbose_name = u\"表名\" verbose_name_plural = verbose_name def __unicode__(self): return self.属性名","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"http://yoursite.com/categories/Python/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"}]},{"title":"hexo +github+阿里云全站加速搭建个人博客","slug":"hexo +github+阿里云全站加速搭建个人博客","date":"2020-07-14T16:00:00.000Z","updated":"2020-07-15T08:48:40.842Z","comments":true,"path":"2020/07/15/hexo +github+阿里云全站加速搭建个人博客/","link":"","permalink":"http://yoursite.com/2020/07/15/hexo%20+github+%E9%98%BF%E9%87%8C%E4%BA%91%E5%85%A8%E7%AB%99%E5%8A%A0%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"1. 前言 1.1 准备工作 一个github账号 安装了 node.js 和 git，使用npm 安装好git 之后，右键打开git bash here输入git信息，下面信息可以填你自己的 git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" 2. 搭建博客 2.1 创建GitHub仓库 ​ 在github里新建一个你的用户名.github.io的仓库，必须是你的GitHub用户名,不然无效，这样将来可以访问你的地址 https://你的用户名.github.io 2.2 全局安装hexo ​ 你可以打开git bash here输入npm install -g hexo-cli 进行安装 2.3 初始化一个hexo项目 ​ 可以在桌面上新建一个文件夹叫做myblog用于以后在里面写博客再上传到github里，然后打开这个文件夹的cmd如下所示（以下命令都是在这个cmd中操作） ​ 接着输入hexo init进行初始化项目,会生成如下目录 ​ 此时本地的仓库初始化完成了，你可以输入hexo server打开本地服务进行查看 2.4 部署到github 打开_congig.yml文件找到deploy进行如下配置： deploy: type: git repo: https://github.com/你的github用户名/你的github用户名.github.io.git branch: master 接着需要一个hexo插件来帮助我们推到github的仓库里面，安装插件： npm install hexo-deployer-git --save 最后只要输入： hexo clean hexo deploy 第一个命令用于清除缓存，第二个用于上传github仓库期间可能需要你登录一个github账号密码，之后写md博客的时候都需要使用这两个命令，这时候就已经部署成功了，打开https://你的用户名.github.io就可以访问了 2.5 更换主题皮肤 在hexo官网找到自己喜欢的theme主题，然后git clone到目录的theme里面 然后将主题名称配置在_congig.yml文件中： # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: 安装的主题名称 然后再利用hexo clean和hexo deploy上传到github里，之后本地进行的修改都要及时上传 ​ 3. 阿里云全站加速 ​ 为什么要使用阿里云全站加速呢，因为这样可以使得我们的博客访问的速度变得更快，当然觉得繁琐可以跳过这一部分 3.1 准备工作 购买一个域名，用来映射github域名（需要备案）可以先用域名加速 用阿里云购买一个全站加速，按量收费即可，基本不花钱 3.2 使用全站加速 首先需要添加域名 ​ 域名填写你的域名 源站信息选择IP,填写如下信息 ​ 上述信息是github的ip地址端口是443，需要填写四个，git pages会在这四个地址中变化 解析域名 ​ 打开解析添加一条记录，记录类型选择CNAME，主机记录按照你加速的域名填，根据下表： ​ 记录值是刚刚全站加速添加域名的CNAME ​ 之后添加即可。 与github域名绑定 在本地的myblog文件中的source目录创建一个CNAME文件，在里面用编辑器输入你在全站加速里面添加的域名。用hexo deploy上传到github就可以了。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"}]},{"title":"Docker在linux系统安装","slug":"Docker在linux系统安装","date":"2020-07-14T14:09:53.000Z","updated":"2020-07-15T03:17:50.161Z","comments":true,"path":"2020/07/14/Docker在linux系统安装/","link":"","permalink":"http://yoursite.com/2020/07/14/Docker%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/","excerpt":"","text":"Docker在linux系统安装 删除旧版本的docker目录文件 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装docker的仓库(repository) $ sudo yum install -y yum-utils $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 下载docker驱动 $ sudo yum install docker-ce docker-ce-cli containerd.io 启动docker $ sudo systemctl start docker 设置docker开机自启 $ sudo systemctl enable docker 查看镜像列表 $ sudo docker images 查看容器列表 $ sudo docker ps","categories":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"Django","slug":"Python/Django","permalink":"http://yoursite.com/categories/Python/Django/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/categories/Docker/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://yoursite.com/tags/Django/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"阿里云","slug":"阿里云","permalink":"http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"}]}